# Log4cplus

## Log4cplus简介

​	log4cplus是用C++编写的[开源](https://edu.csdn.net/cloud/pm_summit?utm_source=blogglc&spm=1001.2101.3001.7020)的日志系统，前身是java编写的log4j系统，受Apache Software License保护，作者是Tad E. Smith。	log4cplus具有线程安全、灵活、以及多粒度控制的特点，通过将日志划分优先级使其可以面向程序调试、运行、测试、和维护等全生命周期。且其可以选择将日志输出到屏幕、文件、NT event log、甚至是远程服务器；并通过指定策略对日志进行定期备份等等。

##  安装方法

1. 解压: `gzip -cd log4cplus-x.x.x.tar.gz` | `tar -xvf xxx.tar`

2. 进入log4cplus根目录: `cd log4cplus-x.x.x`

3. 产生Makefile: `./configure --prefix=/where/to/install -enable-threads=no`

   如果需要指定安装路径可使用--prefix参数, 否则将缺省安装到/usr/local目录下。另外，如果需要单线程版本可通过参数-enable-threads=no指定, 否则默认将安装多线程版本。

4. 创建: `make`

5. 创建/log4cplus/tests目录下的测试用例: `make check`

6. 安装: `make install`

7. 安装成功后将在/usr/local目录或指定的目录下创建include和lib两个子目录及相应文件。其中include目录包含头文件，lib目录包含最终打包生成的静态和动态库。<u>在动态连接log4cplus库时请使用-llog4cplus选项。</u>

## 主要类说明

| 类名      | 说明                                                         |
| --------- | ------------------------------------------------------------ |
| Filter    | 过滤器，过滤输出消息。过滤器，解决哪些信息需要输出的问题，比如DEBUG，WARR,INFO等的输出控制 |
| Layout    | 布局器，控制输出消息的格式。格式化输出信息,解决了如何输出的问题。 |
| Appender  | 挂接器，与布局器和过滤器紧密配合，将特定格式的消息过滤后输出到所挂接的设备终端如屏幕，文件等等)。接收日志的各个设备,如控制台、文件、网络等。解决了输出到哪里去的问题 |
| Logger    | 记录器，保存并跟踪对象日志信息变更的实体，当你需要对一个对象进行记录时，就需要生成一个logger。日志模块,程序中唯一一个必须得使用的模块，解决了在哪里使用日志的问题。 |
| Hierarchy | 分类器，层次化的树型结构，用于对被记录信息的分类，层次中每一个节点维护一个logger的所有信息。 |
| LogLevel  | 优先权，包括TRACE,  DEBUG, INFO, WARNING, ERROR, FATAL。     |

[Log4Cplus 学习笔记 - 配置文件的使用_log4cplus 格式化字符串-CSDN博客](https://blog.csdn.net/kakiebu/article/details/105501833)

## 输出格式控制(layout)

​	log4cplus通过布局器（Layouts）来控制输出的格式，log4cplus提供了三种类型的Layouts，分别是SimpleLayout、PatternLayout、和TTCCLayout。

### SimpleLayout

​	一种简单格式的布局器，在输出的原始信息之前加上LogLevel和一个"-"，如果初始化时没有将布局器附加到挂接器，则默认使用SimpleLayout。

```shell
#比如：
DEBUG - This is  the simple formatted log message...
```

### PatternLayout

​	一种有词法分析功能的模式布局器，类似于C语言的printf()函数，能够对预定义的转换标识符（conversion specifiers）进行解析，转换成特定格式输出。

#### 转换标识符

- "%%"，转义为%, 即std::string pattern = "%%" 时输出"%"。

- "%c"，输出logger名称，比如std::string pattern ="%c" 时输出: "test_logger.subtest",也可以控制logger名称的显示层次，比如"%c{1}"时输出"test_logger"，其中数字表示层次。

- "%D"，显示本地时间，当std::string pattern ="%D" 时输出:"2004-10-16 18:55:45"，%d显示标准时间，所以当std::string pattern ="%d" 时输出"2004-10-16 10:55:45" （因为北京时间位于东8区，比标志时区早8个小时）。

- %d{...}，自定义更详细的显示格式，比如%d{%H:%M:%s}表示要显示小时:分钟:秒。大括号中可显示的预定义标识符如下：

  ```txt
  %a -- 表示礼拜几，英文缩写形式，比如"Fri"
  %A -- 表示礼拜几，比如"Friday"
  %b -- 表示几月份，英文缩写形式，比如"Oct"
  %B -- 表示几月份，"October"
  %c -- 标准的日期＋时间格式，如 "Sat Oct 16 18:56:19 2004"
  %d -- 表示今天是这个月的几号(1-31)"16"
  %H -- 表示当前时刻是几时(0-23)，如 "18"
  %I -- 表示当前时刻是几时(1-12)，如 "6"
  %j -- 表示今天是哪一天(1-366)，如 "290"
  %m -- 表示本月是哪一月(1-12)，如 "10"
  %M -- 表示当前时刻是哪一分钟(0-59)，如 "59"
  %p -- 表示现在是上午还是下午， AM or PM
  %q -- 表示当前时刻中毫秒部分(0-999)，如 "237"
  %Q -- 表示当前时刻中带小数的毫秒部分(0-999.999)，如 "430.732"
  %S -- 表示当前时刻的多少秒(0-59)，如 "32"
  %U -- 表示本周是今年的第几个礼拜，以周日为第一天开始计算(0-53)，如 "41"
  %w -- 表示礼拜几，(0-6, 礼拜天为0)，如 "6"
  %W -- 表示本周是今年的第几个礼拜，以周一为第一天开始计算(0-53)，如 "41"
  %x -- 标准的日期格式，如 "10/16/04"
  %X -- 标准的时间格式，如 "19:02:34"
  %y -- 两位数的年份(0-99)，如 "04"
  %Y -- 四位数的年份，如 "2004"
  %Z -- 时区名，比如 "GMT"
  ```

- "%F"，输出当前记录器所在的文件名称，比如std::string pattern ="%F" 时输出: "main.cpp"。

- "%L"，输出当前记录器所在的文件行号，比如std::string pattern ="%L" 时输出: "51"

- "%l"，输出当前记录器所在的文件名称和行号，比如std::string pattern ="%l" 时输出"main.cpp:51"。

- "%m"，输出原始信息，比如std::string pattern ="%m" 时输出: "teststr"，即上述代码中LOG4CPLUS_DEBUG的第二个参数，这种实现机制可以确保原始信息被嵌入到带格式的信息中。

- "%n"，换行符，没什么好解释的。

- "%p"，输出LogLevel，比如std::string pattern ="%p" 时输出: "DEBUG"。

- "%t"，输出记录器所在的线程ID，比如std::string pattern ="%t" 时输出: "1075298944"。

- "%x"，嵌套诊断上下文NDC (nested diagnostic context) 输出，从堆栈中弹出上下文信息，NDC可以用对不同源的log信息（同时地）交叉输出进行区分，关于NDC方面的详细介绍会在下文中提到。

  - ​	格式对齐，比如std::string pattern ="%-10m"时表示左对齐，宽度是10，此时会输出"teststr  "，当然其它的控制字符也可以相同的方式来使用，比如"%-12d"，"%-5p"等等。

### TTCCLayout

​	是在PatternLayout基础上发展的一种缺省的带格式输出的布局器，其格式由时间，线程ID，Logger和NDC 组成（consists of time, thread, Logger and nested diagnostic context information, hence the name），因而得名。
​	TTCCLayout在构造时，有机会选择显示本地时间或GMT时间，缺省是按照本地时间显示：`TTCCLayout::TTCCLayout(bool use_gmtime  = false)`。如果需要构造TTCCLayout对象时选择GMT时间格式，则传入`true`

## 输出重定向(appender)

### 重定向到控制台

log4cplus默认将输出到控制台，提供ConsoleAppender用于操作。

### 重定向到文件

log4cplus提供了三个类用于文件操作，它们是FileAppender类、RollingFileAppender类、DailyRollingFileAppender类。

#### FileAppender

实现了基本的文件操作功能，构造函数如下：

```c++
FileAppender::FileAppender(const log4cplus::tstring& filename,LOG4CPLUS_OPEN_MODE_TYPE mode =
LOG4CPLUS_FSTREAM_NAMESPACE::ios::trunc,bool immediateFlush = true);

/*
@filename: 文件名
@mode:     文件类型，可选择的文件类型包括app、ate、binary、in、out、trunc，因为实际上只是对stl的一个简单包装，这里就不多讲了。缺省是trunc，表示将先前文件删除。
@immediateFlush: 缓冲刷新标志，如果为true表示每向文件写一条记录就刷新一次缓存，否则直到FileAppender被关闭或文件缓存已满才更新文件，一般是要设置true的，比如你往文件写的过程中出现了错误（如程序非正常退出），即使文件没有正常关闭也可以保证程序终止时刻之前的所有记录都会被正常保存。
*/
```

#### RollingFileAppender

实现可以滚动转储的文件操作功能，构造函数如下：

```cpp
RollingFileAppender::RollingFileAppender(const log4cplus::tstring& filename,long maxFileSize,int maxBackupIndex,
bool immediateFlush=true)
/*
@filename: 文件名
@maxFileSize: 文件的最大尺寸,单位为字节，规定最小为200k==1024*200，不足200k则自动设置为200k
@maxBackupIndex: 最大记录文件数
@immediateFlush: 缓冲刷新标志
*/
```

`RollingFileAppender`类可以根据你预先设定的大小来决定是否转储，当超过该大小，后续log信息会另存到新文件中，除了定义每个记录文件的大小之外，你还要确定在RollingFileAppender类对象构造时最多需要多少个这样的记录文件(maxBackupIndex+1)，当存储的文件数目超过maxBackupIndex+1时，会删除最早生成的文件，保证整个文件数目等于maxBackupIndex+1。然后继续记录，比如以下代码片段：

```cpp
#define LOOP_COUNT 200000
 SharedObjectPtr<Appender> _append(new RollingFileAppender("Test.log", 5*1024, 5));

_append->setName("file  test");

Logger::getRoot().addAppender(_append);

Logger root =  Logger::getRoot();
Logger test =  Logger::getInstance("test");
Logger subTest =  Logger::getInstance("test.subtest");

for(int i=0; i < LOOP_COUNT; ++i)  {
    LOG4CPLUS_DEBUG(subTest, "Entering  loop #"  << i)
}
```

输出结果：

```txt
运行后会产生6个输出文件，Test.log、Test.log.1、Test.log.2、Test.log.3、Test.log.4、Test.log.5其中Test.log存放着最新写入的信息，而最后一个文件中并不包含第一个写入信息，说明已经被不断更新了。
```

<u>需要指出的是，这里除了Test.log之外，每个文件的大小都是200K，而不是我们想像中的5K，这是因为log4cplus中隐含定义了文件的最小尺寸是200K，只有大于200K的设置才生效，<= 200k的设置都会被认为是200K。</u>

#### DailyRollingFileAppender

实现根据频度来决定是否转储的文件转储功能，构造函数如下：

```cpp
DailyRollingFileAppender::DailyRollingFileAppender(const log4cplus::tstring& filename,DailyRollingFileSchedule schedule,bool immediateFlush,int maxBackupIndex)

/*
@filename: 文件名
@schedule : 存储频度
@immediateFlush  : 缓冲刷新标志
@maxBackupIndex : 最大记录文件数
*/
```

DailyRollingFileAppender类可以根据你预先设定的频度来决定是否转储，当超过该频度，后续log信息会另存到新文件中，这里的频度包括：MONTHLY（每月）、WEEKLY（每周）、DAILY（每日）、TWICE_DAILY（每两天）、HOURLY（每时）、MINUTELY（每分）。maxBackupIndex的含义同上所述，比如以下代码片段：

```c++
SharedObjectPtr<Appender> SharedAppenderPtr  _append(new  DailyRollingFileAppender("Test.log", MINUTELY, true, 5));
_append->setName("file  test");
Logger::getRoot().addAppender(_append);
Logger root =  Logger::getRoot();
Logger test =  Logger::getInstance("test");
Logger subTest =  Logger::getInstance("test.subtest");
for(int i=0; i < LOOP_COUNT; ++i) {
    LOG4CPLUS_DEBUG(subTest, "Entering  loop #"  << i)
}
```

输出结果：

```txt
运行后会以分钟为单位，分别生成名为Test.log.2004-10-17-03-03、Test.log.2004-10-17-03-04和Test.log.2004-10-17-03-05这样的文件。
```

需要指出的是这里的"频度"并不是你写入文件的速度，其实是否转储的标准并不依赖你写入文件的速度，而是依赖于写入的那一时刻是否满足了频度条件，即是否超过了以分钟、小时、周、月为单位的时间刻度，如果超过了就另存。

### 嵌入诊断上下文NDC

​	log4cplus中的嵌入诊断上下文（Nested Diagnostic Context），即NDC。对log系统而言，当输入源可能不止一个，而只有一个输出时，往往需要分辩所要输出消息的来源，比如服务器处理来自不同客户端的消息时就需要作此判断，NDC可以为交错显示的信息打上一个标记(stamp)，使得辨认工作看起来比较容易些。这个标记是线程特有的，利用了线程局部存储机制，称为线程私有数据（Thread-Specific Data，或TSD）。相关定义如下，包括定义、初始化、获取、设置和清除操作:

## 基本使用步骤

1. 实例化一个封装了输出介质的appender对象；
2. 实例化一个封装了输出格式的layout对象；
3. 将layout对象绑定(attach)到appender对象；如省略此步骤，默认是简单布局器SimpleLayo对象会绑定到logger。
4. 实例化一个封装了日志输出logger对象,并调用其静态函数getInstance()获得实例,log4cplus::Logger::getInstance("logger_name")；
5. 将appender对象绑定(attach)到logger对象；
6. 设置logger的优先级，如省略此步骤，默认各种有限级的日志都将被输出。

## 使用示例

```c++
/*
*标准使用，严格实现步骤1-6。
*/
#include <log4cplus/logger.h>
#include <log4cplus/consoleappender.h>
#include <log4cplus/layout.h>
#include <log4cplus/loggingmacros.h>
#include <unistd.h>
using namespace log4cplus;
using namespace log4cplus::helpers;
int main()
{
    /*实例化一个挂接器对象*/
    SharedObjectPtr<Appender> _append (new ConsoleAppender());
    _append->setName("append for  test");   

    /*实例化一个布局器对象*/
    std::string pattern = "%d{%Y-%m-%d %H:%M:%S} [%t] %-5p %c - %m%n";
    std::unique_ptr<Layout> _layout(new PatternLayout(pattern));    
 

    /*将挂接器与布局器连接*/
    _append->setLayout( std::move(_layout) );   
 
    /*实例化一个名为test的日志追踪器对象*/
    Logger _logger = Logger::getInstance("test");   
 
    /* step 5: Attach the appender object to the  logger  */
    _logger.addAppender(_append);   
 
    /* step 6: Set a priority for the logger  */
    _logger.setLogLevel(ALL_LOG_LEVEL);  
 
    /* log activity */
    LOG4CPLUS_DEBUG(_logger, "This is the  FIRST log message...");
    sleep(1);
    LOG4CPLUS_WARN(_logger, "This is the  SECOND log message...");
 
    return 0;
}


输出：
2024-12-13 06:54:50 [single] DEBUG test - This is the  FIRST log message...
2024-12-13 06:54:51 [single] WARN  test - This is the  SECOND log message...
```

## 脚本配置

​	除了通过程序实现对log环境的配置之外，log4cplus通过**PropertyConfigurator**类实现了基于脚本配置的功能。通过脚本可以完成对logger、appender和layout的配置，因此可以解决怎样输出，输出到哪里的问题。

### 基本配置

​	基本配置语法主要针对包括rootLogger和non-root logger。

#### 根Logger的配置

```properties
log4cplus.rootLogger=[LogLevel], appenderName, appenderName, ...
```

#### 非根Logger的配置

```properties
log4cplus.logger.logger_name=[LogLevel|INHERITED], appenderName, appenderName, ...
```

<u>说明：INHERITED表示继承父Logger的日志级别。</u>

### 高级配置

#### Appender配置

```properties
log4cplus.appender.appenderName=fully.qualified.name.of.appender.class

fully.qualified.name.of.appeneder.class可用值：
```

| log4cplus::ConsoleAppender          | 终端输出     |
| ----------------------------------- | ------------ |
| log4cplus::FileAppender             | 一般文件输出 |
| log4cplus::RollingFileAppender      | 日志大小输出 |
| log4cplus::DailyRollingFileAppender | 日期输出     |
| log4cplus::SocketAppender           | 网络端口输出 |

**文件通用选项**

| 选项           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| ImmediateFlush | 是否立即刷新（默认为true）log4cplus.appender.ALL_MSGS.ImmediateFlush=true |
| File           | 使用的文件名log4cplus.appender.ALL_MSGS.File=all_msgs.log    |
| Append         | 是否追加到之前的文件log4cplus.appender.ALL_MSGS.Append=true  |
| ReopenDelay    | 先将日志缓存起来，等指定时间之后再往文件中插入，减少文件的保存次数。log4cplus.appender.ALL_MSGS.ReopenDelay=10【单位为秒】 |
| UseLockFile    | 是否使用加锁的方式去写文件，默认是falselog4cplus.appender.ALL_MSGS.UseLockFile=true |
| LockFile       | 使用的加锁文件名log4cplus.appender.ALL_MSGS.LockFile=fuck_are_you.lock[文件名没有具体要求] |
| Locale         | 使用的字符集log4cplus.appender.ALL_MSGS.Locale=chs【en，其他参数具体见imbue参数】 |
| Threshold      | 指定日志消息的输出最低层次log4cplus.appender.ALL_MSGS.Threshold=DEBUG |

**DailyRollingFileAppender相关配置**

| 选项           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| Schedule       | 文件保存频率可选值：MONTHLY,  WEEKLY, DAILY,TWICE_DAILY, HOURLY, MINUTELYlog4cplus.appender.ALL_MSGS.Schedule=MINUTELY |
| MaxBackupIndex | 最多文件个数log4cplus.appender.ALL_MSGS.  MaxBackupIndex=10  |
| DatePattern    | 指定文件名的日期格式1)'.'yyyy-MM: 每月2)'.'yyyy-ww: 每周 3)'.'yyyy-MM-dd: 每天 4)'.'yyyy-MM-dd-a: 每天两次5)'.'yyyy-MM-dd-HH: 每小时6)'.'yyyy-MM-dd-HH-mm: 每分钟log4cplus.appender.ALL_MSGS.DatePattern='.'yyyy-ww |

**RollingFileAppender相关配置**

| 选项           | 作用                                                         |
| -------------- | ------------------------------------------------------------ |
| MaxFileSize    | 最大文件大小，当小于200kb的时候，默认为200kb，单位有（MB、KB）log4cplus.appender.ALL_MSGS.  MaxFileSize=10 |
| MaxBackupIndex | 最多文件个数log4cplus.appender.ALL_MSGS.  MaxBackupIndex=10  |

#### Filter配置

Appender可以附加Filter组成的链表，如果Filter链中存在过滤器Filter， log4cplus在输出日志之前将调用链表中Filter的过滤方法decide(),根据该方法的返回值决定是否过滤该输出日志。

```properties
log4cplus.appender.appenderName.Filters.FilterNumber=fully.qualified.name.of.Filter.class

log4cplus.appender.appenderName.Filters.FilterNumber.FilterCondition=value.of.FilterCondition

log4cplus.appender.appenderName.Filters.AcceptOnMatch=true|false
```

举例：

```properties
log4cplus.appender.append_1.filters.1=log4cplus::spi::LogLevelMatchFilter

log4cplus.appender.append_1.filters.1.LogLevelToMatch=TRACE

log4cplus.appender.append_1.filters.1.AcceptOnMatch=true
```

目前log4plus提供的过滤器包括DenyAllFilter 、LogLevelMatchFilter、LogLevelRangeFilter、和StringMatchFilter。

- LogLevelMatchFilter根据特定的日志级别进行过滤。
  过滤条件包括LogLevelToMatch和AcceptOnMatch（true|false）， 只有当日志的LogLevel值与LogLevelToMatch相同，且AcceptOnMatch为true时才会匹配。

- LogLevelRangeFilter根据根据日志级别的范围进行过滤。
  过滤条件包括LogLevelMin、LogLevelMax和AcceptOnMatch，只有当日志的LogLevel在LogLevelMin、LogLevelMax之间同时AcceptOnMatch为true时才会匹配。

- StringMatchFilter根据日志内容是否包含特定字符串进行过滤。
  过滤条件包括StringToMatch和AcceptOnMatch，只有当日志包含StringToMatch字符串 且AcceptOnMatch为true时会匹配。

- DenyAllFilter则过滤掉所有消息。

过滤条件处理机制类似于**Linux**中**IPTABLE**的**Responsibility chain**机制，（即先deny、再allow）不过执行顺序刚好相反，后写的条件会被先执行，比如：

```properties
log4cplus.appender.append_1.filters.1=log4cplus::spi::LogLevelMatchFilter

log4cplus.appender.append_1.filters.1.LogLevelToMatch=TRACE


log4cplus.appender.append_1.filters.1.AcceptOnMatch=true


#log4cplus.appender.append_1.filters.2=log4cplus::spi::DenyAllFilter
```

会首先执行filters.2的过滤条件，关闭所有过滤器，然后执行filters.1，仅匹配TRACE信息。

#### Layout配置

可以选择不设置、TTCCLayout、或PatternLayout，如果不设置，会输出SimpleLayout格式的日志。

设置TTCCLayout的语法 ：

```properties
log4cplus.appender.ALL_MSGS.layout=log4cplus::TTCCLayout
```

设置PatternLayout的语法：

```properties
log4cplus.appender.append_1.layout=log4cplus::PatternLayout

log4cplus.appender.append_1.layout.ConversionPattern=%d{%m/%d/%y %H:%M:%S,%Q} [%t] %-5p - %m%n
```

## 脚本配置的动态加载

​	多线程版本的log4cplus提供了实用类ConfigureAndWatchThread，该类启动线程对配置脚本进行监控，一旦发现配置脚本被更新则立刻重新加载配置。

类ConfigureAndWatchThread的构造函数定义为：

```cpp
ConfigureAndWatchThread(const log4cplus::tstring& propertyFile, unsigned int millis = 60 * 1000);
//第一个参数propertyFile为配置脚本的路径名，第二个参数为监控时两次更新检查相隔的时间，单位为耗秒ms。
```

# SFINAE

## 介绍

​	SFINAE，即`Substitution Failure Is Not an Error!`可以理解为匹配失败不是错误，更严格的说应该是**<u>参数匹配失败不是一个编译时错误</u>**。即对于通过匹配参数去特化（实例化）模版的时候，匹配失败时不会报错，还会继续去找其他的模版，但当特化好模版后，就相当于生成了对应的代码，此时编译对应代码时如果碰到错误直接报错，因为这已经不属于模版特化参数匹配的问题了。

```cpp
#include <iostream>
using namespace std;
void print( int iNum ) {
     cout<<"void print( int )"<< endl;
}
template < typename _Ty >
void print( _Ty tt ){
      typename _Ty::value_type vt_someval;
      cout<<"template < typename _Ty >"<< endl;
}
int main()
 {
     short siNum = 10;
     print( siNum );
     return 0;
}
```

​    这段代码能否通过编译呢？实践证明，这段代码无法通过编译,出现如下错误：

```shell
main.cpp: In instantiation of ‘void print(_Ty) [with _Ty = short int]’:
main.cpp:14:19: required from here
main.cpp:8:32: error: ‘short int’ is not a class, struct, or union type typename _Ty::value_type vt_someval;

#即调用函数时，编译器发现没有short类型的重载函数，就会利用模版去生成，但又发现模版类型不匹配因此直接报错。
```

​    如何解决这个编译错误呢?有很多方法，比如说我们可以特化short类型:

```cpp
template <>
void print<short>( short st )
{
     cout<<"short st"<<endl;
}
```

​    实践证明，这可以解决这个错误，但是我们这里讨论的是SFINAE。看下面这段代码：

```cpp
#include <iostream>
using namespace std;
void print( int iNum )
{
     cout<<"int print( int )"<< endl;
}
template < typename _Ty >
 void print( _Ty tt, typename _Ty::value_type* pvt_dummy = NULL )
{
      typename _Ty::value_type vt_someval;
      cout<<"template < typename _Ty >"<< endl;
}

int main() {  
   short siNum = 10;
   print( siNum );
   return 0;
}
```

​    如果译器没有问题，那么这段程序是可以通过编译的。为什么编译器会放弃使用short去实例化print模板而选择提升short为int去执行第一个print呢？
​     这个就是SFINAE，C++的一个特性。
​     SFINAE最早由Daveed Vandevorde和Nicolai Josuttis提出，它意味着宁可对有问题的类型不考虑函数的重载也不要产生一个编译时错误。如果这里参数的类型中有一个value_type的嵌套类型，那么它就是重载决议集合的一部分。换句话说：编译器在辨认函数模板时，假如有一个特化会导致编译时错误（即出现编译失败），只要还有别的选择可以被选择，那么就无视这个特化错误而去选择另外的可选选择。比如下面这样使用：

```cpp
class Test {};
int main()
{
	Test a;
	print( a );
	return 0;
} 
```

   那么编译器给出的错误是:   error C2664: “print”: 不能将参数 a从“Test”转换为“int”， 之所以报错，因为这是函数调用问题，而不是与模板特化相关的问题。
   这是C++一个非常重要的特性，如果没有这个特性会对早期的很多代码造成破坏（因为当时没有模板），而且还会产生很多难以理解的代码。
     回过头去看为什么把value_type作为参数的一部分或者是返回值编译器就可以发觉我们提供的类型不能适合语义，而最初的代码又不能被发觉呢？这取决于模板实例化的过程，如果返回值和参数都可以匹配那么这个实例化就等同于成功了，此时此刻就表示编译器已经选择了模板特化而不是其它选择，既然实例化成功了，后面就相当于生成了函数，如果函数中存在参数不匹配问题则直接报错，因为此时不再是模版特化而是函数调用的问题了；但当约束位于参数或者是返回值的时候，如果发现参数不匹配，模板参数匹配的时候就会直接失败，因此这就产生了一个编译时错误，也就相当于实例化失败，失败后继续去匹配模版参数，仍然属于模版特化的问题，这个时候编译器就会按照SFINAE原则去看是否还有其它选择。

# Boost::asio

参考：[Boost Asio介绍-CSDN博客](https://blog.csdn.net/feikudai8460/article/details/107771155)

## 简介

​	asio ( asynchronous input and output)，它提供了一个一致的接口来处理<u>网络通信、定时器、文件I/O</u>等异步操作。

​	Boost Asio库提供了平台无关性的异步数据处理能力（当然它也支持同步数据处理）。

## I/O services 和 I/O objects

​	Boost.Asio异步数据处理主要基于 I/O services 和 I/O objects。

​	I/O services抽象系统I/O接口,提供异步数据传输的能力，是应用程序和系统I/O接口的桥梁。I/O objects 用来初始化某些特定操作，如TCP socket，提供TCP方面可靠数据传输的能力。Boost.Asio只提供**一个类实现 I/O services**, boost::asio::io_service(io_context)。提供多**个I/O objects对象**，如`boost::asio::ip::tcp::socket和boost::asio::deadline_timer`

```c++
#include <boost/asio.hpp>
#include <iostream>
void handler(const boost::system::error_code &ec)
{
    std::cout << "5 s." << std::endl;
}
int main()
{
    boost::asio::io_service io_service;
    boost::asio::deadline_timer timer(io_service, boost::posix_time::seconds(5));
    timer.async_wait(handler);
   /* @param handler:The handler to be called when the timer expires. Copies
   * will be made of the handler as required. The function signature of the
   * handler must be:
   * @code 
   *void handler(const boost::system::error_code& error // Result of operation.); 
   *@endcode
   */
    io_service.run();
}
```

 	在调用 `async_wait()`之后，I/O service调用了run方法因为我们必须把控制权交给操作系统，以便在5s之后调用handler方法。`也就是说，async_wait()`在调用后立即返回，**run()调用后实际阻塞了**。许多操作系统都是通过一个阻塞的函数来实现异步的操作。

## asio两种编程方式

- 同步和异步，同步简单效率高，异步最主要的使用方式。
- io_service调用底层API，io_service有两个作用：跟操作底层打交道，跟IO对象打交道，socket接口调用比如send之类的通知到io_service,io_service再调用底层API

##  steady_timer（定时器）

```c++
typedef basic_waitable_timer<std::chrono::steady_clock> steady_timer;
 /// Constructor.
  /**
   * This constructor creates a timer without setting an expiry time. The
   * expires_at() or expires_from_now() functions must be called to set an
   * expiry time before the timer can be waited on.
   *
   * @param io_service The io_service object that the timer will use to dispatch
   * handlers for any asynchronous operations performed on the timer.
   */
  explicit basic_waitable_timer(boost::asio::io_service& io_service)
      
  
      
//定时时间点，到具体时间点启动
  basic_waitable_timer(boost::asio::io_service& io_service,const time_point& expiry_time)
//定时时间时长，过多久启动
  basic_waitable_timer(boost::asio::io_service& io_service,const duration& expiry_time)
```

## 多线程

​	采用boost::asio::io_service调用run()方法，**和boost::asio::io_service相关联的handler将会在同一线程内触发**。通过采用多线程，应用程序可以同时调用多个run()方法。一旦某个异步操作完成，对应的I/O service将会执行某个线程中的handler方法。如果第二个异步操作在第一个结束后很快完成，I/O service 可以立刻执行其对应的handler,而不用等待第一个handler执行完毕。

```c++
#include <boost/asio.hpp>
#include <boost/thread.hpp>
#include <iostream>
void handler1(const boost::system::error_code &ec)
{
    std::cout << __FUNCTION__<<":5 s." << std::endl;
}
void handler2(const boost::system::error_code &ec)
{
    std::cout << __FUNCTION__<< ":5 s." << std::endl;
}
boost::asio::io_service io_service;
void run()
{  io_service.run();}
int main() 
{
    boost::asio::deadline_timer timer1(io_service, boost::posix_time::seconds(5));
    timer1.async_wait(handler1);
    boost::asio::deadline_timer timer2(io_service, boost::posix_time::seconds(5));
    timer2.async_wait(handler2);
    boost::thread thread1(run);
    boost::thread thread2(run);
    thread1.join();
    thread2.join();
}
```

```shell
g++ main.cpp -lboost_system -lboost_thread
./a.out
handler1:5 s.
handler2:5 s.
```



# Boost::test

## boost::test简介和基本概念

test库是用于单元测试、命令行测试的一系列组件，全称Unit Test Framework(UTF)，优点很多，可以胜任不同强度的测试功能。

1. 一个测试模块大致分为四部：**测试安装**、**测试主体**、**测试清理**、**测试运行器**
2. **测试主体**是实际运行部分，通常包含多个**测试套件**，而测试套件又由多个**测试用例**组成
3. **测试套件**，**测试用例**组合成**测试树**，根节点称为**主测试套件**。进而可以理解以**主测试套件**为根节点，**测试套件**为非叶子节点，**测试用例**为叶子节点**整个主体**。

## 测试模块

1. **主测试套件**必须要有，用`BOOST_TEST_MAIN`或者`BOOST_TEST_MODULE`，而且必须位于头文件#include <boost/test/unit_test.hpp>之前！！！